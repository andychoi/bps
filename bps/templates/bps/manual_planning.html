{# bps/manual_planning.html #}
{% extends "bps/base.html" %}
{% load static %}
{% block title %}
Manual Planning – {{ layout_year.layout.name }} ({{ layout_year.year.code }}/{{ layout_year.version.code }})
{% endblock %}

{% block content %}
<style>
  /* soft-delete visual */
  .row-deleted {
    opacity: 0.6;
    background: #ffe7e7 !important;
  }
  .row-deleted .tabulator-cell {
    text-decoration: line-through;
  }
</style>

<div class="container-fluid mt-3">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h2>
      Manual Planning – {{ layout_year.layout.name }}
      <small class="text-muted">({{ layout_year.year.code }}/{{ layout_year.version.code }})</small>
    </h2>
    <div>
      <button class="btn btn-primary me-2" id="btn-save">Save Changes</button>
      <a class="btn btn-outline-secondary" href="{% url 'admin:bps_planninglayout_change' layout_year.layout.pk %}">Edit Layout</a>
      <button id="btn-xlsx" class="btn btn-outline-secondary">Export Excel</button>
    </div>
  </div>

  {% if header_drivers %}
  <div class="card mb-3">
    <div class="card-header">Header Selection</div>
    <div class="card-body">
      <div class="row g-3 align-items-end">
        {% for hdr in header_drivers %}
        <div class="col-auto">
          <label class="form-label" for="hdr-{{ hdr.key }}">{{ hdr.label }}</label>
          <select id="hdr-{{ hdr.key }}" class="form-select header-select" data-key="{{ hdr.key }}">
            <option value="">(All)</option>
            {% for opt in hdr.choices %}
            <option value="{{ opt.id }}">{{ opt.name }}</option>
            {% endfor %}
          </select>
        </div>
        {% endfor %}
        <div class="col-auto">
          <button id="btn-apply-headers" class="btn btn-outline-primary">Apply</button>
        </div>
      </div>
    </div>
  </div>
  {% endif %}

  <div class="row mb-2">
    <div id="manual-planning-toolbar" class="col-auto align-self-end mb-2">
      <button id="add-row-btn" class="btn btn-sm btn-outline-primary">Add Row</button>
    </div>
  </div>

  <div id="planning-grid"></div>
</div>
{% endblock %}

{% block extra_js %}
<link href="https://cdn.jsdelivr.net/npm/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script>
(function(){
  // ---- Context from server ----
  const CSRF_TOKEN = "{{ csrf_token }}";
  const apiURL         = "{{ api_url }}";
  const updateURL      = "{{ update_url }}";
  const layoutId       = {{ layout_year.pk }};
  const buckets        = {{ buckets_js|safe }};
  const kfCodes        = {{ kf_codes|safe }};
  const kfMeta         = {{ kf_meta_js|safe }};
  const headerDrivers  = {{ header_drivers_js|safe }};
  const rowDrivers     = {{ row_drivers_js|safe }};
  const columnDrivers  = {{ column_drivers_js|safe }};
  const headerDefaults = {{ header_defaults_js|safe }};
  const services       = {{ services_js|safe }};
  const orgUnits       = {{ org_units_js|safe }};
  const rowGroupFields = {{ row_group_fields_js|safe }} || [];
  const rowGroupStartOpen = {{ row_group_start_open_js|safe }};

  // ---- Helpers ----
  function getCookie(name) {
    let v = null;
    document.cookie.split(';').forEach(c => {
      c = c.trim();
      if (c.startsWith(name + '=')) v = decodeURIComponent(c.slice(name.length + 1));
    });
    return v;
  }

  // Parse value field names robustly, even when KF codes contain underscores.
  // Pattern: "<BUCKET>_<KF>[ _<colDim1> _<colDim2> ...]"
  // (trailing col dims count == columnDrivers.length, order matches)
  function parseValueField(field) {
    const parts = String(field).split('_');
    const bucketCode = parts[0];
    const colCount = Array.isArray(columnDrivers) ? columnDrivers.length : 0;

    // All parts after bucket, excluding trailing col dims, are the KF (may include underscores)
    const kfParts = parts.slice(1, parts.length - (colCount || 0) || undefined);
    const kf = kfParts.join('_');

    // Map column-dimension values
    const colVals = colCount > 0 ? parts.slice(parts.length - colCount) : [];
    const columnDimensions = {};
    if (colCount > 0) {
      columnDrivers.forEach((driver, idx) => {
        columnDimensions[driver.key] = colVals[idx];
      });
    }

    return { bucketCode, kf, columnDimensions };
  }

  const toMap = (rows, vKey, lKey) =>
    rows.reduce((acc, r) => (acc[String(r[vKey])] = String(r[lKey]), acc), {});
  const orgUnitMap = toMap(orgUnits, "code", "name");
  const serviceMap = toMap(services, "code", "name");
  const driverMaps = {};
  rowDrivers.forEach(d => { driverMaps[d.key] = toMap(d.choices, "id", "name"); });
  const headerMaps = {};
  headerDrivers.forEach(d => { headerMaps[d.key] = toMap(d.choices, "id", "name"); });
  const columnMaps = {};
  columnDrivers.forEach(d => { columnMaps[d.key] = toMap(d.choices, "id", "name"); });

  const bucketFirstPeriodMap = Object.fromEntries(
    buckets.map(b => [b.code, (b.periods && b.periods[0]) || b.code])
  );

  const rowKeys = rowDrivers.map(d => d.key);
  const columnKeys = columnDrivers.map(d => d.key);
  const hasOrgUnitCol = rowKeys.includes("orgunit");
  const hasServiceCol = rowKeys.includes("service");

  // dimension field names present in the table rows
  const dimFieldNames = [
    ...(hasOrgUnitCol ? ["org_unit_code"] : []),
    ...(hasServiceCol ? ["service_code"] : []),
    ...rowDrivers.filter(d => d.key !== "orgunit" && d.key !== "service").map(d => `${d.key}_code`)
  ];

  function safeLookup(map) {
    return function(cell) {
      const v = cell.getValue();
      if (v == null || v === "") return "";
      const k = String(v);
      return Object.prototype.hasOwnProperty.call(map, k) ? map[k] : "";
    };
  }

  function listEditorParams(valuesMap) {
    return {
      values: valuesMap,
      autocomplete: true,
      listOnEmpty: true,
      allowEmpty: true,
      clearable: true,
      sortValuesList: "asc",
      verticalNavigation: "table",
    };
  }

  function readHeaderSelections() {
    const selected = {};
    document.querySelectorAll(".header-select").forEach(sel => {
      const key = sel.dataset.key;
      const val = sel.value || "";
      selected[key] = val || null;
    });
    return selected;
  }

  function setHeaderDefaults() {
    Object.entries(headerDefaults || {}).forEach(([key, val]) => {
      const el = document.getElementById(`hdr-${key}`);
      if (el && val != null) el.value = String(val);
    });
  }

  // ---- Columns (dimensions) - respecting order from PlanningLayoutDimension ----
  const dimCols = [];
  rowDrivers.forEach(d => {
    if (d.key === "orgunit") {
      dimCols.push({
        title: "Org Unit",
        field: "org_unit_code",
        minWidth: 150,
        widthGrow: 1,
        frozen: true,
        editor: "list",
        editorParams: listEditorParams(orgUnitMap),
        formatter: safeLookup(orgUnitMap),
        headerFilter: "list",
        headerFilterParams: { values: orgUnitMap, autocomplete: true, clearable: true },
        headerTooltip: "Search Org Units",
      });
    } else if (d.key === "service") {
      dimCols.push({
        title: "Service",
        field: "service_code",
        minWidth: 150,
        widthGrow: 1,
        editor: "list",
        editorParams: listEditorParams(serviceMap),
        formatter: safeLookup(serviceMap),
        headerFilter: "list",
        headerFilterParams: { values: serviceMap, autocomplete: true, clearable: true },
        headerTooltip: "Search Services",
      });
    } else {
      dimCols.push({
        title: d.label,
        field: `${d.key}_code`,
        minWidth: 120,
        widthGrow: 1,
        editor: "list",
        editorParams: listEditorParams(driverMaps[d.key] || {}),
        formatter: safeLookup(driverMaps[d.key] || {}),
        headerFilter: "list",
        headerFilterParams: { values: driverMaps[d.key] || {}, autocomplete: true, clearable: true },
        headerTooltip: `Search ${d.label}`,
      });
    }
  });

  // ---- Columns (values) — KEY FIGURES grouped by bucket or year-dependent ----
  const valueColsGrouped = [];
  const yearDependentCols = [];

  function generateColumnCombinations() {
    if (columnDrivers.length === 0) {
      return [{ key: '', label: '', values: {} }];
    }
    const combinations = [{}];
    columnDrivers.forEach(driver => {
      const next = [];
      driver.choices.forEach(choice => {
        combinations.forEach(combo => {
          next.push({
            ...combo,
            [driver.key]: choice.id,
            [`${driver.key}_label`]: choice.name
          });
        });
      });
      combinations.length = 0;
      combinations.push(...next);
    });
    return combinations.map(combo => {
      const key = columnDrivers.map(d => combo[d.key]).join('_');
      const label = columnDrivers.map(d => combo[`${d.key}_label`]).join(' - ');
      const values = {};
      columnDrivers.forEach(d => { values[d.key] = combo[d.key]; });
      return { key, label, values };
    });
  }

  const columnCombinations = generateColumnCombinations();

  kfCodes.forEach(kf => {
    const isYearDependent = kfMeta && kfMeta[kf] && kfMeta[kf].is_year_dependent;
    const decimals = (kfMeta && kfMeta[kf] && typeof kfMeta[kf].decimals === "number") ? kfMeta[kf].decimals : 2;

    if (columnCombinations.length === 1 && !columnCombinations[0].key) {
      if (isYearDependent) {
        yearDependentCols.push({
          title: kf,
          field: `YEAR_${kf}`,
          width: 120,
          editor: overwriteNumberEditor,
          hozAlign: "right",
          bottomCalc: "sum",
          formatter: "money",
          formatterParams: { symbol: "", precision: decimals },
        });
      } else {
        valueColsGrouped.push({
          title: kf,
          columns: buckets.map(b => ({
            title: b.name,
            field: `${b.code}_${kf}`,
            editor: overwriteNumberEditor,
            hozAlign: "right",
            bottomCalc: "sum",
            formatter: "money",
            formatterParams: { symbol: "", precision: decimals },
          })),
        });
      }
    } else {
      columnCombinations.forEach(combo => {
        const comboSuffix = combo.key ? `_${combo.key}` : '';
        const comboLabel = combo.label ? ` (${combo.label})` : '';
        if (isYearDependent) {
          yearDependentCols.push({
            title: `${kf}${comboLabel}`,
            field: `YEAR_${kf}${comboSuffix}`,
            width: 120,
            editor: overwriteNumberEditor,
            hozAlign: "right",
            bottomCalc: "sum",
            formatter: "money",
            formatterParams: { symbol: "", precision: decimals },
            columnDimensions: combo.values,
          });
        } else {
          valueColsGrouped.push({
            title: `${kf}${comboLabel}`,
            columns: buckets.map(b => ({
              title: b.name,
              field: `${b.code}_${kf}${comboSuffix}`,
              editor: overwriteNumberEditor,
              hozAlign: "right",
              bottomCalc: "sum",
              formatter: "money",
              formatterParams: { symbol: "", precision: decimals },
              columnDimensions: combo.values,
            })),
          });
        }
      });
    }
  });

  function overwriteNumberEditor(cell, onRendered, success, cancel) {
    const input = document.createElement("input");
    input.type = "text";
    input.inputMode = "decimal";
    const curr = cell.getValue();
    input.value = (curr == null ? "" : curr);
    let firstKeyReplacePending = true;
    function isPrintable(e){ return e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey; }
    onRendered(() => { input.focus({preventScroll:true}); input.select(); setTimeout(()=>{try{input.select()}catch(_){}}) });
    input.addEventListener("keydown",(e)=>{
      if (e.key === "Enter"){ success(input.value); return; }
      if (e.key === "Escape"){ cancel(); return; }
      if (firstKeyReplacePending && isPrintable(e)){
        input.value = e.key;
        try{ input.setSelectionRange(input.value.length, input.value.length);}catch(_){}
        firstKeyReplacePending = false;
        e.preventDefault();
        return;
      }
    });
    input.addEventListener("blur", () => success(input.value));
    return input;
  }

  function buildAjaxParams() {
    const params = { layout: layoutId };
    const hdr = readHeaderSelections();
    Object.entries(hdr).forEach(([k,v]) => { if (v != null && v !== "") params[`header_${k}`] = v; });
    return params;
  }

  function labelForGroup(field, raw) {
    if (raw == null || raw === "") return "(blank)";
    const key = String(raw);
    if (field === "org_unit_code") return orgUnitMap[key] || key;
    if (field === "service_code")  return serviceMap[key]  || key;
    const dimKey = field.endsWith("_code") ? field.slice(0, -5) : field;
    const map = driverMaps[dimKey] || {};
    return map[key] || key;
  }

  const tableOptions = {
    layout: "fitColumns",
    ajaxURL: apiURL,
    ajaxConfig: { credentials: "include" },
    ajaxParams: buildAjaxParams(),
    ajaxResponse: (_url, _params, res) => res,
    columns: [
      {
        title: "",
        field: "_actions",
        width: 48,
        headerSort: false,
        hozAlign: "center",
        frozen: true,
        formatter: (_cell, _params, _onRendered) => "🗑️",
        cellClick: (_e, cell) => toggleDeleteRow(cell.getRow()),
        tooltip: (comp) => {
          const row = (comp && typeof comp.getRow === "function") ? comp.getRow() : null;
          const data = row ? row.getData() : null;
          if (data && data.__marked_delete) return "Undo delete";
          return "Mark row for delete";
        },
      },
      ...dimCols,
      ...valueColsGrouped,
      ...yearDependentCols,
    ],
    pagination: "local",
    paginationSize: 50,
    history: true,
    validationMode: "highlight",
    rowFormatter: function(row){
      const d = row.getData();
      row.getElement().classList.toggle("row-deleted", !!d.__marked_delete);
    },
  };

  const rowGroupingOn = Array.isArray(rowGroupFields) && rowGroupFields.length > 0;
  if (rowGroupingOn) {
    tableOptions.groupBy = rowGroupFields.length === 1 ? rowGroupFields[0] : rowGroupFields;
    tableOptions.groupStartOpen = !!rowGroupStartOpen;
    tableOptions.groupToggleElement = "header";
    tableOptions.groupClosedShowCalcs = true;
    tableOptions.groupHeader = function(value, count, _data, group) {
      const field = typeof group.getField === "function" ? group.getField() : "";
      const label = labelForGroup(field, value);
      return `${label} <span class="text-muted">(${count})</span>`;
    };
  }

  const table = new Tabulator("#planning-grid", tableOptions);

  setHeaderDefaults();
  const btnApply = document.getElementById("btn-apply-headers");
  if (btnApply) {
    btnApply.addEventListener("click", (e) => {
      e.preventDefault();
      table.setData(apiURL, buildAjaxParams());
    });
  }

  document.getElementById("btn-xlsx").addEventListener("click", () => {
    table.download("xlsx", `${window.ply_code || "planning"}.xlsx`, {sheetName: "Plan"});
  });

  const blankRow = (() => {
    const base = {};
    rowDrivers.forEach(d => {
      if (d.key === "orgunit") base["org_unit_code"] = null;
      else if (d.key === "service") base["service_code"] = null;
      else base[`${d.key}_code`] = null;
    });
    kfCodes.forEach(kf => {
      const isYearDependent = kfMeta && kfMeta[kf] && kfMeta[kf].is_year_dependent;
      columnCombinations.forEach(combo => {
        const comboSuffix = combo.key ? `_${combo.key}` : '';
        if (isYearDependent) {
          base[`YEAR_${kf}${comboSuffix}`] = null;
        } else {
          buckets.forEach(b => { base[`${b.code}_${kf}${comboSuffix}`] = null; });
        }
      });
    });
    return base;
  })();

  document.getElementById("add-row-btn").addEventListener("click", async () => {
    try {
      const row = await table.addRow({ ...blankRow }, true);
      const firstDim = table.getColumnDefinitions().find(c => dimFieldNames.includes(c.field));
      if (firstDim) row.getCell(firstDim.field).edit();
    } catch (e) { console.error(e); }
  });

  function toggleDeleteRow(row) {
    const d = row.getData();
    d.__marked_delete = !d.__marked_delete;
    if (d.__marked_delete) {
      row.getCells().forEach(c => {
        try { c.cancelEdit && c.getElement().classList.contains("tabulator-editing") && c.cancelEdit(); } catch {}
      });
    }
    row.update(d);
    row.getElement().classList.toggle("row-deleted", d.__marked_delete);
  }

  async function sendGridUpdates(payload){
    let res = await fetch(updateURL, {
      method: "PATCH",
      credentials: "include",
      headers: { 
        "Content-Type": "application/json", 
        "X-CSRFToken": getCookie("csrftoken") 
      },
      body: JSON.stringify(payload),
    });
    if (res.status === 404 || res.status === 405){
      res = await fetch(updateURL, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCookie("csrftoken") },
        body: JSON.stringify(payload),
      });
    }
    return res;
  }

  // Build VALUE_FIELDS including both period-based and year-dependent fields with column dimensions
  const VALUE_FIELDS = [];
  kfCodes.forEach(kf => {
    const isYearDependent = kfMeta && kfMeta[kf] && kfMeta[kf].is_year_dependent;
    columnCombinations.forEach(combo => {
      const comboSuffix = combo.key ? `_${combo.key}` : '';
      if (isYearDependent) {
        VALUE_FIELDS.push(`YEAR_${kf}${comboSuffix}`);
      } else {
        buckets.forEach(b => VALUE_FIELDS.push(`${b.code}_${kf}${comboSuffix}`));
      }
    });
  });

  function dimsFromRowData(d, headerSelected, columnDimensions = {}){
    const base = {};
    const extraDims = {};

    const orgFromRow = hasOrgUnitCol ? d.org_unit_code : null;
    const orgFromHdr = headerSelected.orgunit || null;
    base.org_unit = orgFromRow || orgFromHdr || null;

    const svcFromRow = hasServiceCol ? d.service_code : null;
    const svcFromHdr = headerSelected.service || null;
    base.service = svcFromRow || svcFromHdr || null;

    const firstClassDims = ['orgunit', 'service', 'account', 'year', 'version', 'period'];

    rowDrivers
      .filter(dr => dr.key !== "orgunit" && dr.key !== "service")
      .forEach(dr => { 
        const value = d[`${dr.key}_code`] ?? null;
        if (firstClassDims.includes(dr.key)) base[dr.key] = value;
        else if (value) extraDims[dr.key] = value;
      });

    headerDrivers
      .filter(hd => hd.key !== "orgunit" && hd.key !== "service")
      .forEach(hd => { 
        const value = headerSelected[hd.key] ?? null;
        if (firstClassDims.includes(hd.key)) base[hd.key] = value;
        else if (value) extraDims[hd.key] = value;
      });

    columnDrivers.forEach(cd => {
      const value = columnDimensions[cd.key] ?? null;
      if (value) extraDims[cd.key] = value;
    });

    // Send extra dimensions as flat fields for API processing
    Object.entries(extraDims).forEach(([key, value]) => {
      base[key] = value;
    });
    return base;
  }

  document.getElementById("btn-save").addEventListener("click", () => {
    const editedCells = table.getEditedCells();
    const headerSelected = readHeaderSelections();
    const updates = [];
    const missingOrgRows = new Set();

    const rowsMarkedForDelete = table.getRows().filter(r => !!r.getData().__marked_delete);
    const deletedRowIds = new Set(rowsMarkedForDelete.map(r => r.getIndex()));

    // 0) delete_row updates first
    for (const row of rowsMarkedForDelete) {
      const d = row.getData();
      const base = dimsFromRowData(d, headerSelected);
      if (!base.org_unit) {
        missingOrgRows.add(row.getPosition(true));
        continue;
      }
      let pushed = 0;
      for (const field of VALUE_FIELDS) {
        const val = d[field];
        if (val != null && val !== "") {
          const { bucketCode, kf, columnDimensions } = parseValueField(field);
          const baseDims = dimsFromRowData(d, headerSelected, columnDimensions);
          const update = { ...baseDims, key_figure: kf, delete_row: true };
          update.period = (bucketCode === "YEAR") ? null : (bucketFirstPeriodMap[bucketCode] || bucketCode);
          updates.push(update);
          pushed++;
        }
      }
      if (pushed === 0) {
        const baseDims = dimsFromRowData(d, headerSelected);
        updates.push({ ...baseDims, delete_row: true });
      }
    }

    const valueCells = editedCells
      .filter(c => VALUE_FIELDS.includes(c.getField()))
      .filter(c => !deletedRowIds.has(c.getRow().getIndex()));
    const dimCells   = editedCells
      .filter(c => dimFieldNames.includes(c.getField()))
      .filter(c => !deletedRowIds.has(c.getRow().getIndex()));

    // 1) dimension changes → move values
    const rowsWithDimChange = Array.from(new Set(dimCells.map(c => c.getRow())));
    for (const row of rowsWithDimChange) {
      if (deletedRowIds.has(row.getIndex())) continue;
      const dNow = row.getData();

      const oldD = { ...dNow };
      for (const c of dimCells.filter(cc => cc.getRow() === row)) {
        oldD[c.getField()] = c.getOldValue();
      }

      for (const field of VALUE_FIELDS) {
        const { bucketCode, kf, columnDimensions } = parseValueField(field);
        const val = dNow[field];
        if (val == null || val === "") continue;

        const newDimsWithCol = dimsFromRowData(dNow, headerSelected, columnDimensions);
        const oldDimsWithCol = dimsFromRowData(oldD,  headerSelected, columnDimensions);
        if (!newDimsWithCol.org_unit || !oldDimsWithCol.org_unit) {
          missingOrgRows.add(row.getPosition(true));
          continue;
        }

        const baseUpdate = { key_figure: kf, value: val };
        const baseDelete = { key_figure: kf, value: "" };

        if (bucketCode === "YEAR") {
          updates.push({ ...newDimsWithCol, ...baseUpdate, period: null });
          updates.push({ ...oldDimsWithCol, ...baseDelete, period: null });
        } else {
          const period = bucketFirstPeriodMap[bucketCode] || bucketCode;
          updates.push({ ...newDimsWithCol, ...baseUpdate, period });
          updates.push({ ...oldDimsWithCol, ...baseDelete, period });
        }
      }
    }

    // 2) plain numeric edits
    const skipRows = new Set(rowsWithDimChange.map(r => r.getIndex()));
    for (const cell of valueCells){
      const row = cell.getRow();
      if (skipRows.has(row.getIndex())) continue;

      const d = row.getData();
      const field = cell.getField();

      const { bucketCode, kf, columnDimensions } = parseValueField(field);

      const base = dimsFromRowData(d, headerSelected, columnDimensions);
      if (!base.org_unit){
        missingOrgRows.add(row.getPosition(true));
        continue;
      }

      const update = { ...base, key_figure: kf, value: cell.getValue() };
      update.period = (bucketCode === "YEAR") ? null : (bucketFirstPeriodMap[bucketCode] || bucketCode);
      updates.push(update);
    }

    if (!updates.length) {
      if (missingOrgRows.size) {
        alert("Org Unit is required (from header or row) before saving.\nRows: " + [...missingOrgRows].join(", "));
      } else {
        alert("No valid changes to save.");
      }
      return;
    }

    sendGridUpdates({
      layout_year: layoutId,
      headers: headerSelected,
      delete_zeros: true,
      delete_blanks: true,
      updates,
    })
    .then(async (res) => {
      const data = await res.json().catch(() => ({}));
      if (res.status === 207 || (Array.isArray(data.errors) && data.errors.length)) {
        const msg = [
          "Some updates failed:",
          ...(data.errors || []).slice(0, 10).map(e => `• ${e.error}`),
          (data.errors || []).length > 10 ? `…and ${data.errors.length - 10} more` : ""
        ].join("\n");
        alert(msg);
      } else if (!res.ok) {
        throw new Error(data.detail || "Save failed");
      } else {
        alert(`All changes saved. Updated ${data.updated ?? 0}, deleted ${data.deleted ?? 0}.`);
      }
      table.replaceData(apiURL, buildAjaxParams());
    })
    .catch((err) => { console.error(err); alert("Save failed."); });
  });

})();
</script>
{% endblock %}