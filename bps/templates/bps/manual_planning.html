{# bps/manual_planning.html #}
{% extends "bps/base.html" %}
{% load static %}
{% block title %}
Manual Planning – {{ layout_year.layout.name }} ({{ layout_year.year.code }}/{{ layout_year.version.code }})
{% endblock %}

{% block content %}
<style>
  /* soft-delete visual */
  .row-deleted {
    opacity: 0.6;
    background: #ffe7e7 !important;
  }
  .row-deleted .tabulator-cell {
    text-decoration: line-through;
  }
</style>

<div class="container-fluid mt-3">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h2>
      Manual Planning – {{ layout_year.layout.name }}
      <small class="text-muted">({{ layout_year.year.code }}/{{ layout_year.version.code }})</small>
    </h2>
    <div>
      <button class="btn btn-primary me-2" id="btn-save">Save Changes</button>
      <a class="btn btn-outline-secondary" href="{% url 'admin:bps_planninglayout_change' layout_year.layout.pk %}">Edit Layout</a>
      <button id="btn-xlsx" class="btn btn-outline-secondary">Export Excel</button>
    </div>
  </div>

  {% if header_drivers %}
  <div class="card mb-3">
    <div class="card-header">Header Selection</div>
    <div class="card-body">
      <div class="row g-3 align-items-end">
        {% for hdr in header_drivers %}
        <div class="col-auto">
          <label class="form-label" for="hdr-{{ hdr.key }}">{{ hdr.label }}</label>
          <select id="hdr-{{ hdr.key }}" class="form-select header-select" data-key="{{ hdr.key }}">
            <option value="">(All)</option>
            {% for opt in hdr.choices %}
            <option value="{{ opt.id }}">{{ opt.name }}</option>
            {% endfor %}
          </select>
        </div>
        {% endfor %}
        <div class="col-auto">
          <button id="btn-apply-headers" class="btn btn-outline-primary">Apply</button>
        </div>
      </div>
    </div>
  </div>
  {% endif %}

  <div class="row mb-2">
    <div id="manual-planning-toolbar" class="col-auto align-self-end mb-2">
      <button id="add-row-btn" class="btn btn-sm btn-outline-primary">Add Row</button>
    </div>
  </div>

  <div id="planning-grid"></div>
</div>
{% endblock %}

{% block extra_js %}
<link href="https://cdn.jsdelivr.net/npm/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script>
(function(){
  // ---- Context from server ----
  const CSRF_TOKEN = "{{ csrf_token }}";
  const apiURL         = "{{ api_url }}";
  const updateURL      = "{{ update_url }}";
  const layoutId       = {{ layout_year.pk }};
  const buckets        = {{ buckets_js|safe }};
  const kfCodes        = {{ kf_codes|safe }};
  const kfMeta         = {{ kf_meta_js|safe }};
  const headerDrivers  = {{ header_drivers_js|safe }};
  const rowDrivers     = {{ row_drivers_js|safe }};
  const headerDefaults = {{ header_defaults_js|safe }};
  const services       = {{ services_js|safe }};
  const orgUnits       = {{ org_units_js|safe }};
  const rowGroupFields = {{ row_group_fields_js|safe }} || [];
  const rowGroupStartOpen = {{ row_group_start_open_js|safe }};

  // ---- Helpers ----
  function getCookie(name) {
    let v = null;
    document.cookie.split(';').forEach(c => {
      c = c.trim();
      if (c.startsWith(name + '=')) v = decodeURIComponent(c.slice(name.length + 1));
    });
    return v;
  }

  const toMap = (rows, vKey, lKey) =>
    rows.reduce((acc, r) => (acc[String(r[vKey])] = String(r[lKey]), acc), {});
  const orgUnitMap = toMap(orgUnits, "code", "name");
  const serviceMap = toMap(services, "code", "name");
  const driverMaps = {};
  rowDrivers.forEach(d => { driverMaps[d.key] = toMap(d.choices, "id", "name"); });
  const headerMaps = {};
  headerDrivers.forEach(d => { headerMaps[d.key] = toMap(d.choices, "id", "name"); });

  const bucketFirstPeriodMap = Object.fromEntries(
    buckets.map(b => [b.code, (b.periods && b.periods[0]) || b.code])
  );

  const rowKeys = rowDrivers.map(d => d.key);
  const hasOrgUnitCol = rowKeys.includes("orgunit");
  const hasServiceCol = rowKeys.includes("service");

  // dimension field names present in the table rows
  const dimFieldNames = [
    ...(hasOrgUnitCol ? ["org_unit_code"] : []),
    ...(hasServiceCol ? ["service_code"] : []),
    ...rowDrivers.filter(d => d.key !== "orgunit" && d.key !== "service").map(d => `${d.key}_code`)
  ];

  function safeLookup(map) {
    return function(cell) {
      const v = cell.getValue();
      if (v == null || v === "") return "";
      const k = String(v);
      return Object.prototype.hasOwnProperty.call(map, k) ? map[k] : "";
    };
  }

  function listEditorParams(valuesMap) {
    return {
      values: valuesMap,
      autocomplete: true,
      listOnEmpty: true,
      allowEmpty: true,
      clearable: true,
      sortValuesList: "asc",
      verticalNavigation: "table",
    };
  }

  function readHeaderSelections() {
    const selected = {};
    document.querySelectorAll(".header-select").forEach(sel => {
      const key = sel.dataset.key;
      const val = sel.value || "";
      selected[key] = val || null;
    });
    return selected;
  }

  function setHeaderDefaults() {
    Object.entries(headerDefaults || {}).forEach(([key, val]) => {
      const el = document.getElementById(`hdr-${key}`);
      if (el && val != null) el.value = String(val);
    });
  }

  // ---- Columns (dimensions) ----
  const dimCols = [];
  if (hasOrgUnitCol) {
    dimCols.push({
      title: "Org Unit",
      field: "org_unit_code",
      width: 220,
      frozen: true,
      editor: "list",
      editorParams: listEditorParams(orgUnitMap),
      formatter: safeLookup(orgUnitMap),
      headerFilter: "list",
      headerFilterParams: { values: orgUnitMap, autocomplete: true, clearable: true },
      headerTooltip: "Search Org Units",
    });
  }
  if (hasServiceCol) {
    dimCols.push({
      title: "Service",
      field: "service_code",
      width: 220,
      editor: "list",
      editorParams: listEditorParams(serviceMap),
      formatter: safeLookup(serviceMap),
      headerFilter: "list",
      headerFilterParams: { values: serviceMap, autocomplete: true, clearable: true },
      headerTooltip: "Search Services",
    });
  }
  dimCols.push(
    ...rowDrivers
      .filter(d => d.key !== "orgunit" && d.key !== "service")
      .map(d => ({
        title: d.label,
        field: `${d.key}_code`,
        width: 180,
        editor: "list",
        editorParams: listEditorParams(driverMaps[d.key] || {}),
        formatter: safeLookup(driverMaps[d.key] || {}),
        headerFilter: "list",
        headerFilterParams: { values: driverMaps[d.key] || {}, autocomplete: true, clearable: true },
        headerTooltip: `Search ${d.label}`,
      }))
  );

  // ---- Columns (values) — KEY FIGURES grouped by bucket ----
  const valueColsGrouped = kfCodes.map(kf => ({
    title: kf,
    columns: buckets.map(b => ({
      title: b.name,
      field: `${b.code}_${kf}`,
      editor: overwriteNumberEditor,
      hozAlign: "right",
      bottomCalc: "sum",
      formatter: "money",
      formatterParams: { symbol: "", precision: (kfMeta && kfMeta[kf] && typeof kfMeta[kf].decimals === "number") ? kfMeta[kf].decimals : 2 },
    })),
  }));

  // Simple overwrite-on-first-key editor
  function overwriteNumberEditor(cell, onRendered, success, cancel) {
    const input = document.createElement("input");
    input.type = "text";
    input.inputMode = "decimal";
    const curr = cell.getValue();
    input.value = (curr == null ? "" : curr);
    let firstKeyReplacePending = true;
    function isPrintable(e){ return e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey; }
    onRendered(() => { input.focus({preventScroll:true}); input.select(); setTimeout(()=>{try{input.select()}catch(_){}}) });
    input.addEventListener("keydown",(e)=>{
      if (e.key === "Enter"){ success(input.value); return; }
      if (e.key === "Escape"){ cancel(); return; }
      if (firstKeyReplacePending && isPrintable(e)){
        input.value = e.key;
        try{ input.setSelectionRange(input.value.length, input.value.length);}catch(_){}
        firstKeyReplacePending = false;
        e.preventDefault();
        return;
      }
    });
    input.addEventListener("blur", () => success(input.value));
    return input;
  }

  // Build query params for server request
  function buildAjaxParams() {
    const params = { layout: layoutId };
    const hdr = readHeaderSelections();
    Object.entries(hdr).forEach(([k,v]) => { if (v != null && v !== "") params[`header_${k}`] = v; });
    return params;
  }

  // Helpful group header label: translate codes to display text
  function labelForGroup(field, raw) {
    if (raw == null || raw === "") return "(blank)";
    const key = String(raw);
    if (field === "org_unit_code") return orgUnitMap[key] || key;
    if (field === "service_code")  return serviceMap[key]  || key;
    const dimKey = field.endsWith("_code") ? field.slice(0, -5) : field;
    const map = driverMaps[dimKey] || {};
    return map[key] || key;
  }

  // ---- Tabulator init ----
  const tableOptions = {
    layout: "fitColumns",
    ajaxURL: apiURL,
    ajaxConfig: { credentials: "include" },
    ajaxParams: buildAjaxParams(),
    ajaxResponse: (_url, _params, res) => res,
    columns: [
      {
        title: "",
        field: "_actions",
        width: 48,
        headerSort: false,
        hozAlign: "center",
        frozen: true,
        formatter: (_cell, _params, _onRendered) => "🗑️",
        cellClick: (_e, cell) => toggleDeleteRow(cell.getRow()),
        tooltip: (comp) => {
          // Only CellComponents have getRow()
          const row = (comp && typeof comp.getRow === "function") ? comp.getRow() : null;
          const data = row ? row.getData() : null;
          if (data && data.__marked_delete) return "Undo delete";
          return "Mark row for delete";
        },
      },
      ...dimCols,
      ...valueColsGrouped,
    ],
    pagination: "local",
    paginationSize: 50,
    history: true,
    validationMode: "highlight",
    rowFormatter: function(row){
      const d = row.getData();
      row.getElement().classList.toggle("row-deleted", !!d.__marked_delete);
    },
  };

  const rowGroupingOn = Array.isArray(rowGroupFields) && rowGroupFields.length > 0;
  if (rowGroupingOn) {
    tableOptions.groupBy = rowGroupFields.length === 1 ? rowGroupFields[0] : rowGroupFields;
    tableOptions.groupStartOpen = !!rowGroupStartOpen;
    tableOptions.groupToggleElement = "header";
    tableOptions.groupClosedShowCalcs = true;
    tableOptions.groupHeader = function(value, count, _data, group) {
      const field = typeof group.getField === "function" ? group.getField() : "";
      const label = labelForGroup(field, value);
      return `${label} <span class="text-muted">(${count})</span>`;
    };
  }

  const table = new Tabulator("#planning-grid", tableOptions);

  // Header defaults + Apply
  setHeaderDefaults();
  const btnApply = document.getElementById("btn-apply-headers");
  if (btnApply) {
    btnApply.addEventListener("click", (e) => {
      e.preventDefault();
      table.setData(apiURL, buildAjaxParams());
    });
  }

  // ---- Export / Add Row ----
  document.getElementById("btn-xlsx").addEventListener("click", () => {
    table.download("xlsx", `${window.ply_code || "planning"}.xlsx`, {sheetName: "Plan"});
  });

  const blankRow = (() => {
    const base = {};
    if (hasOrgUnitCol) base["org_unit_code"] = null;
    if (hasServiceCol) base["service_code"] = null;
    rowDrivers
      .filter(d => d.key !== "orgunit" && d.key !== "service")
      .forEach(d => { base[`${d.key}_code`] = null; });
    buckets.forEach(b => { kfCodes.forEach(kf => { base[`${b.code}_${kf}`] = null; }); });
    return base;
  })();

  document.getElementById("add-row-btn").addEventListener("click", async () => {
    try {
      const row = await table.addRow({ ...blankRow }, true);
      const firstDim = table.getColumnDefinitions().find(c => dimFieldNames.includes(c.field));
      if (firstDim) row.getCell(firstDim.field).edit();
    } catch (e) { console.error(e); }
  });

  // ---- Soft delete toggle ----
  function toggleDeleteRow(row) {
    const d = row.getData();
    d.__marked_delete = !d.__marked_delete;
    // If marking for delete, we should also clear any pending cell edits to avoid re-creating later
    if (d.__marked_delete) {
      row.getCells().forEach(c => {
        try { c.cancelEdit && c.getElement().classList.contains("tabulator-editing") && c.cancelEdit(); } catch {}
      });
    }
    row.update(d);
    row.getElement().classList.toggle("row-deleted", d.__marked_delete);
  }

  // ---- Utility: send updates (PATCH → fallback POST) ----
  async function sendGridUpdates(payload){
    let res = await fetch(updateURL, {
      method: "PATCH",
      credentials: "include",
      headers: { 
        "Content-Type": "application/json", 
        "X-CSRFToken": getCookie("csrftoken") 
    },
      body: JSON.stringify(payload),
    });
    if (res.status === 404 || res.status === 405){
      res = await fetch(updateURL, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCookie("csrftoken") },
        body: JSON.stringify(payload),
      });
    }
    return res;
  }

  // ---- Save logic (numeric changes + dimension "move" + soft deletes) ----
  const VALUE_FIELDS = buckets.flatMap(b => kfCodes.map(kf => `${b.code}_${kf}`));

  function dimsFromRowData(d, headerSelected){
    const base = {}
    // org unit
    const orgFromRow = hasOrgUnitCol ? d.org_unit_code : null;
    const orgFromHdr = headerSelected.orgunit || null;
    base.org_unit = orgFromRow || orgFromHdr || null;
    // service
    const svcFromRow = hasServiceCol ? d.service_code : null;
    const svcFromHdr = headerSelected.service || null;
    base.service = svcFromRow || svcFromHdr || null;
    // extra row dims
    rowDrivers
      .filter(dr => dr.key !== "orgunit" && dr.key !== "service")
      .forEach(dr => { base[dr.key] = d[`${dr.key}_code`] ?? null; });
    // header-only dims
    headerDrivers
      .filter(hd => hd.key !== "orgunit" && hd.key !== "service")
      .forEach(hd => { base[hd.key] = headerSelected[hd.key] ?? null; });
    return base;
  }

  document.getElementById("btn-save").addEventListener("click", () => {
    const editedCells = table.getEditedCells();
    const headerSelected = readHeaderSelections();
    const updates = [];
    const missingOrgRows = new Set();

    // rows marked for deletion (virtual → physical on save)
    const rowsMarkedForDelete = table.getRows().filter(r => !!r.getData().__marked_delete);
    const deletedRowIds = new Set(rowsMarkedForDelete.map(r => r.getIndex()));

    // 0) Push delete_row updates first
    for (const row of rowsMarkedForDelete) {
      const d = row.getData();
      const base = dimsFromRowData(d, headerSelected);
      if (!base.org_unit) {
        missingOrgRows.add(row.getPosition(true));
        continue;
      }

      let pushed = 0;
      for (const field of VALUE_FIELDS) {
        const val = d[field];
        if (val != null && val !== "") {
          const sep = field.indexOf("_");
          const bucketCode = field.slice(0, sep);
          const kf = field.slice(sep + 1);
          const period = bucketFirstPeriodMap[bucketCode] || bucketCode;

          updates.push({
            ...base,
            period,
            key_figure: kf,
            delete_row: true,
          });
          pushed++;
        }
      }

      // Fallback: if no non-empty value cells found, send a single row-level delete
      if (pushed === 0) {
        updates.push({
          ...base,
          delete_row: true, // no period/key_figure => API deletes all facts matching the dims
        });
      }
    }

    // separate numeric and dimension edits, excluding deleted rows
    const valueCells = editedCells
      .filter(c => VALUE_FIELDS.includes(c.getField()))
      .filter(c => !deletedRowIds.has(c.getRow().getIndex()));
    const dimCells   = editedCells
      .filter(c => dimFieldNames.includes(c.getField()))
      .filter(c => !deletedRowIds.has(c.getRow().getIndex()));

    // 1) Handle rows where *any* dimension changed: move all existing numeric values
    const rowsWithDimChange = Array.from(new Set(dimCells.map(c => c.getRow())));
    for (const row of rowsWithDimChange){
      if (deletedRowIds.has(row.getIndex())) continue; // already deleting
      const dNow = row.getData();

      // reconstruct "old" dimensions by taking current data but replacing edited fields with their oldValue
      const oldD = { ...dNow };
      for (const c of dimCells.filter(cc => cc.getRow() === row)){
        oldD[c.getField()] = c.getOldValue();
      }

      const newDims = dimsFromRowData(dNow, headerSelected);
      const oldDims = dimsFromRowData(oldD, headerSelected);

      if (!newDims.org_unit || !oldDims.org_unit){
        missingOrgRows.add(row.getPosition(true));
        continue;
      }

      for (const field of VALUE_FIELDS){
        const sep = field.indexOf("_");
        const bucketCode = field.slice(0, sep);
        const kf = field.slice(sep + 1);
        const period = bucketFirstPeriodMap[bucketCode] || bucketCode;
        const val = dNow[field];
        if (val == null || val === "") continue;

        // write new
        updates.push({ ...newDims, period, key_figure: kf, value: val });
        // delete old
        updates.push({ ...oldDims, period, key_figure: kf, value: "" });
      }
    }

    // 2) Handle plain numeric cell edits (skip rows that had dimension moves or are deleted)
    const skipRows = new Set(rowsWithDimChange.map(r => r.getIndex()));
    for (const cell of valueCells){
      const row = cell.getRow();
      if (skipRows.has(row.getIndex())) continue;

      const d = row.getData();
      const field = cell.getField();
      const sep = field.indexOf("_");
      const bucketCode = field.slice(0, sep);
      const kf = field.slice(sep + 1);
      const period = bucketFirstPeriodMap[bucketCode] || bucketCode;

      const base = dimsFromRowData(d, headerSelected);
      if (!base.org_unit){
        missingOrgRows.add(row.getPosition(true));
        continue;
      }
      updates.push({ ...base, period, key_figure: kf, value: cell.getValue() });
    }

    if (!updates.length) {
      if (missingOrgRows.size) {
        alert("Org Unit is required (from header or row) before saving.\nRows: " + [...missingOrgRows].join(", "));
      } else {
        alert("No valid changes to save.");
      }
      return;
    }

    sendGridUpdates({
      layout_year: layoutId,
      headers: headerSelected,
      delete_zeros: true,
      delete_blanks: true,
      updates,
    })
    .then(async (res) => {
      const data = await res.json().catch(() => ({}));
      if (res.status === 207 || (Array.isArray(data.errors) && data.errors.length)) {
        const msg = [
          "Some updates failed:",
          ...(data.errors || []).slice(0, 10).map(e => `• ${e.error}`),
          (data.errors || []).length > 10 ? `…and ${data.errors.length - 10} more` : ""
        ].join("\n");
        alert(msg);
      } else if (!res.ok) {
        throw new Error(data.detail || "Save failed");
      } else {
        alert(`All changes saved. Updated ${data.updated ?? 0}, deleted ${data.deleted ?? 0}.`);
      }
      // Always reload from server so the grid reflects the DB after save
      table.replaceData(apiURL, buildAjaxParams()).then(() => {
        // clear all soft-delete marks post-refresh
      });
    })
    .catch((err) => { console.error(err); alert("Save failed."); });
  });

})();
</script>
{% endblock %}